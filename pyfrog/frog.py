import numpy as np
"""Module pyfrog.frog
    Usually, the user doesn't need to call theses functions.
    Thus they are not exposed to the user.
"""

def OPF_to_tau( O_t ):
    """
        OPF_to_tau( O_t ) converts a matrix in the outer product form into a frog trace with a valid delay axis.

        steps:
            -shift row number i by i
            -swap left and right side of the matrix
            -reverse the direction of delay

        arguments:
            O_t : matrix in outer product form

        returns:
            O_t : matrix where the columns correspond to a certain time delay between the pulses.
    """
    Nf = O_t.shape[1]
    idx = np.mod( -(Nf-1)*np.arange(Nf)[:,None] + np.arange(Nf), Nf )
    _O_t = O_t
    _O_t = _O_t[np.arange(Nf)[:,None], idx]
    _O_t = np.fft.fftshift( _O_t, 1 )
    _O_t = np.fliplr( _O_t )
    return _O_t

def tau_to_OPF( O_t ):
    """
        tau_to_OPF( O_t ) converts a matrix with a valid delay axis to the outer product form.

        Inverse of OPF_to_tau. See OPF_to_tau for arguments.
    """
    Nf = O_t.shape[1]
    _O_t = O_t
    _O_t = np.fliplr( _O_t )
    _O_t = np.fft.fftshift( _O_t, 1 )
    idx = np.mod( (Nf-1)*np.arange(Nf)[:,None] + np.arange(Nf), Nf )
    _O_t = _O_t[np.arange(Nf)[:,None], idx]
    return _O_t


def _generate_trace( P_t, G_t, nonlinearity='shg', return_field=False ):
    """
        _generate_trace( P_t, G_t, nonlinearity="SHG", return_field=False ) generates a frog trace from two complex electric fields.

        arguments:
            P_t : complex array containing the electric field of the pulse in time domain.
            G_t : complex array containing the electric field of the gate pulse in time domain.
            nonlinearity : Nonlinearity used to generate the trace. At the moment only SHG is available
            return_field : boolean, if true the function returns the trace AND the frequency dependent electric field (FROG trace before abs()^2 )

        returns:
            the normalized FROG trace generated by the pulses P_t and G_t.
            (optional) the elctric field that generates the frog trace
        
    """
    if nonlinearity == 'shg':
        _gamma = lambda x: x
        _invgamma = lambda x: x
    O_t = np.outer( P_t, G_t ) + np.outer( _invgamma(G_t), _gamma(P_t) )
    O_t = OPF_to_tau( O_t )
    O_f = np.fft.fft( O_t, axis=0 )
    if return_field:
        return abs(O_f)**2 / np.amax( abs(O_f)**2 ), O_f/np.amax(abs(O_f))
    return abs(O_f)**2 / np.amax( abs(O_f)**2 )


def generate_trace( spectrum, phase, spectrum_gate=None,
                   phase_gate=None, nonlinearity='shg',
                   return_field=False ):
    """
        generate_trace( spectrum, phase, spectrum_gate=None, phase_gate=None, nonlinearity='shg', return_field=False ) calculates a frog trace. The unknown pulse and the gate are generated from spectrum+phase and spectrum_gate+phase_gate, respectively. If spectrum_gate or phase_gate is None, the gate pulse is equal to the unknown pulse.

        arguments:
            spectrum : vector containing the power spectral density (PSD) of the pulse.
            phase : vector containing the spectral phase of the pulse.
            spectrum_gate (optional) : vector containing the PSD of the gate pulse.
            phase_gate (optional) : vector containing the spectral phase of the gate pulse.
            nonlinearity : name of the nonlinearity. Default is 'shg'. Other nonlinearities are currently not available
            return_field : boolean, if True then this function returns additionally the electric field ( FROG trace before abs^2 )

        returns:
            trace : array containing the frog trace
            O_f (optional) : array containing the complex electric 
    """
    P_f = np.sqrt( spectrum ) * np.exp( -1j * phase )
    P_t = np.fft.ifft( P_f )
    if (spectrum_gate is None) or (phase_gate is None):
        G_t = P_t
    else:
        G_f = np.sqrt( spectrum_gate ) * np.exp( -1j * phase_gate )
        G_t = np.fft.ifft( G_f )
    return _generate_trace( P_t, G_t, nonlinearity=nonlinearity, return_field=return_field )

def g_error( trace1, trace2 ):
    """
        g_error( trace1, trace2 ) calculates the FROG error between two traces.
        
        arguments:
            trace1 : FROG trace
            trace2 : another FROG trace

        returns:
            g : the rms error per pixel
    """
    Ntau, Nf = trace1.shape
    mu = np.sum( trace1 * trace2 )/ np.sum( trace2**2 )
    return np.sqrt( 1 / Ntau/ Nf * np.sum( abs( trace1 - mu * trace2 )**2 ) )
